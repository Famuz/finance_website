{"version":3,"sources":["repositories/repository.js"],"names":["fs","require","crypto","module","exports","[object Object]","filename","Error","this","accessSync","err","writeFileSync","attrs","id","randomId","records","getAll","push","writeAll","JSON","parse","promises","readFile","encoding","writeFile","stringify","randomBytes","toString","find","record","filteredRecords","filter","Object","assign","filters","found","key"],"mappings":"AAAA,MAAMA,GAAKC,QAAQ,MACbC,OAASD,QAAQ,UAEvBE,OAAOC,QAAU,MACfC,YAAYC,GACV,IAAIA,EACF,MAAM,IAAIC,MAAM,6CAGlBC,KAAKF,SAAWA,EAChB,IACEN,GAAGS,WAAWD,KAAKF,UACnB,MAAOI,GACPV,GAAGW,cAAcH,KAAKF,SAAU,OAIpCD,aAAaO,GACXA,EAAMC,GAAKL,KAAKM,WAEhB,MAAMC,QAAgBP,KAAKQ,SAI3B,OAHAD,EAAQE,KAAKL,SACPJ,KAAKU,SAASH,GAEbH,EAGTP,eAEE,OAAOc,KAAKC,YAAYpB,GAAGqB,SAASC,SAASd,KAAKF,SAAU,CAC1DiB,SAAU,UAIdlB,eAAeU,SAEPf,GAAGqB,SAASG,UAAUhB,KAAKF,SAAUa,KAAKM,UAAUV,EAAS,KAAM,IAG3EV,WACE,OAAOH,OAAOwB,YAAY,GAAGC,SAAS,OAGxCtB,aAAaQ,GAEX,aADsBL,KAAKQ,UACZY,KAAKC,GAAUA,EAAOhB,KAAOA,GAG9CR,aAAaQ,GACX,MACMiB,SADgBtB,KAAKQ,UACKe,OAAOF,GAAUA,EAAOhB,KAAOA,SACzDL,KAAKU,SAASY,GAGtBzB,aAAaQ,EAAID,GACf,MAAMG,QAAgBP,KAAKQ,SACrBa,EAASd,EAAQa,KAAKC,GAAUA,EAAOhB,KAAOA,GAEpD,IAAKgB,EACH,MAAM,IAAItB,MAAM,mBAAmBM,eAGrCmB,OAAOC,OAAOJ,EAAQjB,SAChBJ,KAAKU,SAASH,GAGtBV,eAAe6B,GACb,MAAMnB,QAAgBP,KAAKQ,SAI3B,IAAK,IAAIa,KAAUd,EAAS,CAC1B,IAAIoB,GAAQ,EAEZ,IAAI,IAAIC,KAAOF,EACTL,EAAOO,KAASF,EAAQE,KAC1BD,GAAQ,GAIZ,GAAGA,EACD,OAAON","file":"repository.js","sourcesContent":["const fs = require('fs');\nconst crypto = require('crypto');\n\nmodule.exports = class Repository {\n  constructor(filename) {\n    if(!filename) {\n      throw new Error('Creating a repository requires a filename');\n    }\n\n    this.filename = filename;\n    try {\n      fs.accessSync(this.filename);\n    } catch (err) {\n      fs.writeFileSync(this.filename, '[]');\n    }\n  }\n\n  async create(attrs) {\n    attrs.id = this.randomId();\n\n    const records = await this.getAll();\n    records.push(attrs);\n    await this.writeAll(records);\n\n    return attrs;\n  }\n\n  async getAll() {\n    // Open the file called this.filename\n    return JSON.parse(await fs.promises.readFile(this.filename, {\n      encoding: 'utf8'\n    }));\n  }\n\n  async writeAll(records) {\n    // write the updated 'records' array back to this.filename\n    await fs.promises.writeFile(this.filename, JSON.stringify(records, null, 2));\n  }\n\n  randomId() {\n    return crypto.randomBytes(4).toString('hex');\n  }\n\n  async getOne(id) {\n    const records = await this.getAll();\n    return records.find(record => record.id === id);\n  }\n\n  async delete(id) {\n    const records = await this.getAll();\n    const filteredRecords = records.filter(record => record.id !== id);\n    await this.writeAll(filteredRecords);\n  }\n\n  async update(id, attrs) {\n    const records = await this.getAll();\n    const record = records.find(record => record.id === id);\n\n    if (!record) {\n      throw new Error(`Records with id ${id} not found`);\n    } \n\n    Object.assign(record, attrs);\n    await this.writeAll(records);\n  }\n\n  async getOneBy(filters) {\n    const records = await this.getAll();\n\n\n\n    for (let record of records) {\n      let found = true;\n\n      for(let key in filters) {\n        if (record[key] !== filters[key]) {\n          found = false;\n        }\n      }\n\n      if(found) {\n        return record;\n      }\n    }\n  }\n}"]}